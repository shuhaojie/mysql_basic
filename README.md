## 一、事务

### 1. 什么是事务

#### （1）概念

事务是数据库系统中保证一组相关操作具有原子性（不可分割）、一致性、隔离性和持久性（ACID）特性的**逻辑工作单元**。它通过明确的开始（BEGIN）、结束（COMMIT 或 ROLLBACK）边界，确保这些操作要么全部成功永久生效，要么全部失败完全回滚。

- 表现形式：**逻辑工作单元**，它把多个操作（SQL语句）捆绑在一起。

- 目的：保证ACID 特性，这是事务存在的根本原因。
- 核心目的：在ACID中，最核心的目的，是原子性，“全部成功”或“全部失败”是其最核心的承诺。
- 关键操作：明确的边界控制，`BEGIN` 标记开始，`COMMIT` 确认永久生效（成功结束），`ROLLBACK` 撤销所有更改（失败结束）。

#### （2）类比
类比理解：想象在填写一份复杂的申请表（事务）：

1. **开始填表（`START TRANSACTION`）**： 你拿出一张新表开始填写。
2. **填写多个字段（执行SQL操作）**： 你填写姓名、地址、电话等信息（INSERT/UPDATE/DELETE）。此时，表还没交上去，你可以随意修改或划掉重写。
3. **检查并提交（`COMMIT`）**： 你仔细检查所有信息都正确无误后，**正式递交（提交）** 给柜台。柜台收下你的表，存档（持久化），这份表就正式生效了。其他人（其他事务）现在才能看到或查询到这份表的内容（受隔离级别限制）。
4. **发现错误并作废（`ROLLBACK`）**： 如果你在提交前发现填错了，你可以直接把这张表**撕掉（回滚）** ，重新拿一张新表填写（数据库恢复到填表前的状态）。柜台永远不知道你填错过。

例如下面的事务，由于id是pk，因此会rollback

```sql
begin;
insert into user(id, username, password, email) values (1, "haojie", "123456", "haojie@qq.com");
insert into user(id, username, password, email) values (1, "yuwen", "123456", "yuwen@qq.com");
commit;
```

### 2. 事务的开启

#### （1）单sql语句

在MySQL中，事务是默认开启的`autocommit=ON`, **当执行一条DML语句，MySQL会隐式的提交事务，也就是说每一条DML语句都是在一个事务之内的**。

#### （2）多sql语句

**当我们想把多条SQL语句包裹在一个事务中时**，可以使用如下的方式

```sql
begin; # 或者start transaction;
# DML语句
commit; # 或者rollback
```

#### （3）pymysql

对pymysql会有个误区，认为`with con.cursor() as cursor`这个语句就是开启事务，其实并不对。

- PyMySQL中，事务时默认关闭的：`autocommit=False`
- **当执行第一条修改数据的 SQL 语句（如 `INSERT/UPDATE/DELETE`）时，事务会隐式开启**

```python
import pymysql

con = pymysql.connect(host="localhost", user="root", passwd="805115148",
                      db="mysql_basic", port=int(3306), charset='utf8')

try:
    with con.cursor() as cursor:
        # 执行SQL（此时事务隐式开启）
        cursor.execute("insert into user(id, username, password, email) values (1, 'haojie', '123456', 'haojie@qq.com')")
        cursor.execute("insert into user(id, username, password, email) values (1, 'yuwen', '123456', 'yuwen@qq.com')")

    # 手动提交事务
    con.commit()  # ⭐⭐⭐ 关键步骤 ⭐⭐⭐

except Exception as e:
    # 出错时回滚
    con.rollback()  # ⭐⭐⭐ 关键步骤 ⭐⭐⭐
    print(f"Transaction failed: {e}")

finally:
    con.close()
```

这里注意对比：

（1）游标（cursor）只是执行 SQL 的工具，事务是连接（connection）级别的操作

（2）pymysql也可以设置事务自动提交：

```python
# 如果设置 autocommit=True，每条 SQL 会立即提交（不推荐用于事务）
con = pymysql.connect(..., autocommit=True)
```

（3）事务边界：一个连接可以包含多个事务；每次 `commit()` 或 `rollback()` 后会结束当前事务，下次执行修改语句时开启新事务。

#### （4）sqlalchemy

同pymysql，`with Session() as session`这个语句不会开启事务，当执行第一个数据库操作（查询/修改）时，SQLAlchemy 会**自动开启一个新事务**。

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine("mysql+pymysql://user:pass@localhost/db")
Session = sessionmaker(bind=engine)

# 推荐的事务处理方式
with Session() as session:  # 创建会话
    try:
        # 执行数据库操作（此时隐式开启事务）
        user = session.query(User).filter_by(id=1).first()
        user.name = "Updated Name"
        
        # 显式提交事务
        session.commit()  # ⭐⭐⭐ 关键步骤 ⭐⭐⭐
    
    except Exception as e:
        # 出错时回滚
        session.rollback()  # ⭐⭐⭐ 关键步骤 ⭐⭐⭐
        print(f"事务失败: {e}")
        raise
```

### 3.  事务的特性

事务的四大特性，分别是ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。

#### （1）原子性

**原子性可以说是事务最重要的特性**，无论一个事务里有多少执行步骤，这所有的步骤合起来是一个最小的执行单元，要么不做，要么全做，不存在只做到一半情况。

以转账为例，现实世界的转账是一个不可分割的操作：要么压根儿就没转，要么转账成功，不存在中间状态，也就是转了一半的这种情况，这种规则称之为`原子性`。

数据库中的一条操作可能被分解成若干个步骤，比**如先修改缓存页，之后再刷新到磁盘等**，而且任何一个可能的时间都可能发生意想不到的错误，可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的，而使操作执行不下去。为了保证在数据库世界中某些操作的原子性，需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子。

#### （2）一致性

事务执行前与执行后数据内在的逻辑始终是成立的，比如转账前与转账后两人存款的总和始终不变。

另外知乎这个回答提供了另外一个观点：提到事务，就会说ACID，但是**事务的AID是手段，C是目的**。就像提到保镖，会说强壮、功夫好、踏实、安全，这里强壮、功夫好、踏实都是手段，安全是目的。

> 参考，如何理解数据库事务中的一致性的概念？ - 莺歌一笑的回答 - 知乎https://www.zhihu.com/question/31346392/answer/362597203

#### （3）隔离性

它指的是**多个事务并发执行时，每个事务的操作和数据与其他事务相互隔离，互不干扰**，如同只有该事务自己在操作数据库一样。

#### （4）持久性

事务做完了就是做完了，就生效了。就像钱转给别人后当前这比转账交易就结束了，不可能再倒回来。

### 4. 并发事务问题

数据准备

```sql
insert into user(id, username, email, password) values (1, "haojie", "haojie@qq.com", "123456");
```

#### （1）脏读

脏读（Dirty Read）指的是，事务A读取了**事务B未提交**的修改数据，若事务B随后回滚，事务A读到的就是无效的“脏数据”。

事务A：

```sql
# 步骤1: 事务A, 设置隔离级别为读未提交
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
# 步骤3: 事务A, 开启事务
begin;
# 步骤4: 事务A, 修改数据但是不提交
UPDATE user SET password = "654321" WHERE id = 1;
# 步骤6: 事务A, 回滚
rollback;
```

事务B：

```sql
# 步骤2: 事务B, 设置隔离级别为读未提交
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
# 步骤5: 事务B, 读取未提交的数据: 654321
SELECT * FROM user WHERE id = 1;
# 步骤7: 事务B, 再读取回滚后的数据: 123456
SELECT * FROM user WHERE id = 1;
```

**隔离级别要求**：`READ COMMITTED` 及以上可避免。

#### （2）不可重复读

不可重复读（Non-Repeatable Read）指的是，事务A内**多次读取同一数据**，因事务B的**修改并提交**，导致前后结果不一致。

事务A：

```sql
# 步骤1: 事务A, 设置隔离级别为读已提交
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
# 步骤3: 事务A, 开启事务
begin;
# 步骤4: 事务A, 读取数据: 123456
select password from user where id=1;
# 步骤8: 事务A, 第二次读取: 654321
select password from user where id=1;
```

事务B：

```sql
# 步骤2: 事务B, 设置隔离级别为读已提交
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
# 步骤5: 事务B, 开启事务
begin;
# 步骤6: 事务B, 修改数据
UPDATE user SET password="654321" WHERE id = 1;
# 步骤7: 事务B, 提交数据
COMMIT;
```

**隔离级别要求**：`REPEATABLE READ` 及以上可避免。

#### （3）幻读

事务A**多次执行相同范围查询**，因事务B**插入或删除**符合条件的数据并提交，导致返回的行数变化（出现“幻影行”）。

事务A：

```sql
# 步骤1: 事务A, 设置隔离级别为可重复读
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
# 步骤3: 事务A, 开启事务
begin;
# 步骤4: 事务A, 读取数据: 空
select * from user where id>1;
# 步骤8: 事务A, 第二次读取: 有一条数据
select * from user where id>1;
```

事务B：

```sql
# 步骤2: 事务B, 设置隔离级别为可重复读
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
# 步骤5: 事务B, 开启事务
begin;
# 步骤6: 事务B, 新增数据
insert into user(id, username, email, password) values (2, "yuwen", "yuwen@qq.com", "123456");
# 步骤7: 事务B, 提交数据
COMMIT;
```

**隔离级别要求**：`SERIALIZABLE` 可严格避免（MySQL的`REPEATABLE READ`通过间隙锁也可避免）。

#### （4）问题

> 1、为什么脏读比不可重复读更严重？

答：因为脏读读的是**未提交的中间状态数据**，不可重复读读取的是**已提交的真实数据**。

脏读：事务B将余额从50改为100（未提交），事务A读到100并允许用户提款60，随后事务B回滚余额恢复为50，造成资金损失。

不可重复读：虽然事务内一致性被破坏，但数据本身是有效的（如余额从50变为100是业务认可的）

### 5. 事务隔离级别

为什么需要隔离？

- 数据库需要同时处理多个用户/应用的请求（多个事务）。
- 如果不对并发事务进行任何控制，它们可能会同时读写相同的数据项，导致最终结果混乱、不可预测，破坏数据的一致性。

隔离的本质：

- 隔离性是一种**保证机制**。它通过数据库系统内部的并发控制协议（主要是锁机制或多版本并发控制）来实现。
- 它确保了**一个正在执行的事务在其提交之前，它对数据的中间修改对其他并发事务是不可见的**。
- 它让用户感觉不到其他并发事务的存在，仿佛数据库在某个时刻只执行这一个事务。

MySQL的默认隔离级别是可重复读

#### （1）读未提交

- **定义：**读未提交（READ UNCOMMITTED）指的是事务可以读取其他**尚未提交**的事务所做的修改。

- **允许的问题：**
  - **脏读：**❌ 肯定发生。事务A读取了事务B未提交的修改，如果事务B回滚，事务A读到的就是无效数据。
  - **不可重复读：** ❌ 可能发生。
  - **幻读：** ❌ 可能发生。
  - **丢失更新：** ❌ 可能发生。
- **使用场景：** 极少使用。可能出现在对数据一致性要求极低、只追求最高吞吐量的特殊场景（如某些统计、监控），且能容忍数据短暂不一致或无效

#### （2）读已提交

- **定义：** 事务只能读取其他**已经提交**的事务所做的修改。这是**Oracle 等数据库的默认级别**。
- **防止的问题：**
  - **脏读：** ✅ 防止。只能读到已提交的数据。
- **允许的问题：**
  - **不可重复读：** ❌ 可能发生。事务A第一次读取某行后，事务B修改该行并提交，事务A再次读取该行会得到新值。
  - **幻读：** ❌ 可能发生。事务A第一次执行范围查询后，事务B插入或删除符合该范围的行并提交，事务A再次执行相同查询会得到不同的行集。
- **使用场景：** 适用于大多数不需要严格保证同一事务内多次读取结果一致的OLTP场景。能有效防止脏读，并发性能较好。是许多应用的合理选择。

#### （3）可重复读

- **定义：** 可重复读（REPEATABLE READ），是 **MySQL InnoDB 存储引擎的默认隔离级别**。确保在同一个事务内，多次读取**同一范围**的数据会返回**相同**的结果（第一次读取建立快照）。
- **防止的问题：**
  - **脏读：** ✅ 防止。
  - **不可重复读：** ✅ 防止。同一事务内多次读取同一行，结果总是相同。
  - **丢失更新：** ✅ InnoDB 通过行锁和 next-key lock 通常可以防止。
- **允许的问题 (SQL 标准)：**
  - **幻读：** ❌ SQL 标准允许发生。
- **使用场景：** MySQL 的默认级别，提供了很好的数据一致性保证（防止脏读、不可重复读和幻读），同时通过 MVCC 保持了较好的读并发性能。适用于需要保证事务内数据视图一致的场景（如对账、复杂报表生成、需要基于稳定视图进行多次操作）。

#### （4）串行化

- **定义：** 最严格的隔离级别。它强制所有事务**串行执行**，如同事务是按顺序一个接一个执行一样。
- **防止的问题：**
  - **脏读：** ✅ 防止。
  - **不可重复读：** ✅ 防止。
  - **幻读：** ✅ 防止。
  - **丢失更新：** ✅ 防止。
- 锁冲突的概率大大增加，可能导致大量事务等待，**性能最低**。
- **使用场景：** 对数据一致性要求**极其严格**，可以接受显著性能下降的场景。例如，某些金融核心交易、票务系统最后的库存扣减等。一般只在非常必要的情况下使用。

## 二、索引

> 参考https://www.bilibili.com/video/BV1Kr4y1i7ru?spm_id_from=333.788.videopod.episodes&vd_source=e204e7b48214ba273c6eb797fd8b7a51&p=68

### 1. 索引介绍

#### （1）本质

索引(index)是帮助MySQL高效获取数据的数据结构，在数据之外，**数据库系统还维护着满足特定查找算法的数据结构**，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

#### （2）作用

假如没有索引，我们要去查一个数据，实际上是非常慢的，例如下面去找年龄为45的，需要从上往下一直找，找到了之后还不能停，因为可能有多个年龄为45的。 这种方式称之为全表扫描，它的性能非常低。

<img src="./assets/image-20250610092213542.png" alt="image-20250610092213542" style="zoom: 67%;" />

如果我们此时用一个索引，例如二叉树。第一个数据36作为根节点，比它大设为右节点，比它小设为左节点，每个数据依次往下排，那么同样是这些数据，我们可以建立这样一个二叉树。

<img src="./assets/image-20250610092319258.png" alt="image-20250610092319258" style="zoom:67%;" />

此时再去找年龄为45的，显然快得多，只需要36 -> 48 -> 45这个步骤，匹配三次即可找到。

### 2. B+树结构

Mysql默认的引擎是InnoDB，它使用的索引是B+树

#### （1）二叉树

上面说的二叉树会有一个缺点，如果我们的数据是顺序插入，例如36 -> 34 -> 33 -> 23 -> 22 -> 20 -> 19 -> 17。**此时它相当于形成了一个链表**，见下面右图所示， 此时如果我们去查17这个数，检索效率是较慢的。

<img src="./assets/image-20250610092757225.png" alt="image-20250610092757225" style="zoom:60%;" />

#### （2）B树

- 度数：一个节点的子节点个数。例如下图中第一行的度数就是5，因为有5个子节点。
- key：节点中存储的**有序键值**。例如下图中第一行的指针就是4，因为有4个键值。
- 指针：指向**子节点**的指针。例如下图中第一行的key就是5，因为指向了5个子节点。

![image-20250610193641945](./assets/image-20250610193641945.png)

B树是如何分裂的呢？以一颗最大度数为5的b-tree为例，现在我们有0023，0234，0345，0899，

- 最开始我们有4个数0023，0234，0345，0899，此时由于key值数足够，不会发生裂变，数据有序存储

![image-20250610204446735](./assets/image-20250610204446735.png)

- 如果此时新增一个数1200，此时由于key值不够，会发生裂变，如何裂变呢？中间元素向上裂变

![image-20250610204620292](./assets/image-20250610204620292.png)

- 此时如果再插入一个1234，由于比0345大，会走右侧，放到1200的右边

![image-20250610204728391](./assets/image-20250610204728391.png)

- 插入1500

  ![image-20250610205204412](./assets/image-20250610205204412.png)

- 然后再插入1000，该如何分裂呢？还是一样，中间元素向上分裂，1200向上分裂到第一行，然后把另外4个数给分开，和前面一样

![image-20250610205100195](./assets/image-20250610205100195.png)

- 继续往里面插一些数，变成这样

![image-20250610205906162](./assets/image-20250610205906162.png)

- 然后我们再插入一个2456，此时树就变成了3层

![image-20250610205951469](./assets/image-20250610205951469.png)

#### （3）B+树

B+树和B树有两个不一样：

- 所有元素都会出现在叶子节点（见下图最后一行，包含了所有的数据）
- 叶子节点形成了一个单向链表

![image-20250610210241163](./assets/image-20250610210241163.png)

- 假设我们有四个数，0232，0234，0567，1000，当我们再次插入一个数890，此时B+树会变成如下形式，它和前面不一样，0567向上裂变的同时**还出现在了叶子节点**，这是因为前面说的第一个特性，B+树的所有元素都会出现在叶子节点

![image-20250610210917470](./assets/image-20250610210917470.png)

- 再插入1234

![image-20250610211121751](./assets/image-20250610211121751.png)

- 此时如果再插入2345，1000向上裂变的同时，还会出现在叶子节点

![image-20250610211158885](./assets/image-20250610211158885.png)

#### （4）MySQL B+树

MySQL在B+树的基础上做了改良：非叶子节点只是起到索引数据的作用，并不存储具体的数据，具体数据存在叶子节点

![image-20250610212423223](./assets/image-20250610212423223.png)

### 3. 索引分类

#### （1）按类型

- 主键索引：针对于表中的主键创建的索引，它是自动创建的
- 唯一索引：避免同一个表中某数据列中的值重复，当我们加唯一约束的时候，会自动创建唯一索引
- 常规索引：快速定位特定数据

#### （2）按存储形式

- 聚集索引：将数据存储与索引放到了一起，索引结构的叶子节点保存了行数据，聚集索引只会有一个。
- 二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，二级索引可以存在多个。

聚集索引选取规则：

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一索引作为聚集索引
- 如果不存在主键，并且没有合适的唯一索引，InnoDB会自动生成一个rowid作为隐藏的聚集索引

**也就是说，MySQL一定会有聚集索引**

### 4. 索引的使用

#### （1）挂数据

- 聚集索引：叶子节点挂的是具体的数据
- 二级索引：叶子节点挂的是对应的主键值

![image-20250610214357686](./assets/image-20250610214357686.png)

#### （2）回表查询

当我们要执行一个查询，`select * from user where name='Arm';`

- 首先走二级索引，去查`Arm`对应的`id=10`
- 再去走聚集索引，去查`id=10`对应的数据块

![image-20250610215442292](./assets/image-20250610215442292.png)

这个过程就是回表查询：先根据二级索引查主键值，再根据主键值拿到这一行的行数据

### 5. 索引使用规则

#### （1）最左前缀法则

最左前缀法则针对的是联合索引，指的是查询从索引的最左列开始，并且不跳过索引中的列，**如果跳过某一列，索引将部分式效**。

例如我们有一个联合索引profession，age，status，如下图所示

![image-20250612204739477](./assets/image-20250612204739477.png)

- 第一个sql语句：`select * from tb_user where profession="软件工程" and age=3l and status ='0';`，查看执行计划，可以看到用到了索引，索引长度54

![image-20250612205014612](./assets/image-20250612205014612.png)

- 第二个sql语句：`select * from tb_user where profession="软件工程" and age=3l;`，查看执行计划，可以看到也用到了索引，索引长度49

![image-20250612205124897](./assets/image-20250612205124897.png)

- 第三个sql语句：`select * from tb_user where profession="软件工程";`，查看执行计划，可以看到仍然用到了索引，索引长度47

![image-20250612205241472](./assets/image-20250612205241472.png)

- 第四个sql语句：`select * from tb_user where age=3l and status ='0';`，查看执行计划，可以看到没用到索引，type字段为ALL，表示全表扫描。这是因为它不满足最左前缀法则，最左边的列professio没有出现。

![image-20250612205732764](./assets/image-20250612205732764.png)

- 第五个sql语句：`select * from tb_user where profession="软件工程" and status ='0';`，查看执行计划，可以看到用到了索引。按照前面的计算，profession索引的长度是47，age索引的长度是5，status索引的长度是2，但是下面执行计划里，索引的长度却是47，说明**索引部分失效**，这是因为我们跳过了age索引

![image-20250612210255681](./assets/image-20250612210255681.png)

#### （2） 范围查询

也是针对的联合索引，出现范围查询(`<`,`>`)，范围查询右侧的列索引失效

例如：`select * from tb_user where profession="软件工程" and age>30 and status ='0';`，查看执行计划，虽然用到了索引，但是索引的长度是49，说明没有用到status索引

![image-20250612211057713](./assets/image-20250612211057713.png)

在业务允许的范围内，尽量使用`>=`

![image-20250612211037427](./assets/image-20250612211037427.png)

#### （3）索引失效情况

- 不要在索引列上进行运算操作，否则索引将失效。例如对比下面两个sql

![image-20250612211501934](./assets/image-20250612211501934.png)

- 字符串类型不加单引号，也会不走索引。例如下面的sql，虽然不加引号也可以查出，但是全表扫描了。

![image-20250612211748568](./assets/image-20250612211748568.png)

- 如果仅仅是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效。例如对比下面两个sql，后面一个没有用到索引。

![image-20250612212218750](./assets/image-20250612212218750.png)

- 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。例如下面的sql，由于age没有单独的索引，因此索引失效。

![image-20250612212655938](./assets/image-20250612212655938.png)

#### （4）sql提示

SQL提示，就是在SQL语句中加入一些人为的提示来达到优化操作的目的，是优化数据库的一个重要手段。

- 如果profession既是联合索引，又是单列索引，可以加上`use index(idx_user_pro)`来使用单列索引：`explain select * from tb_user use index(idx_user_pro) where profession='软件工程”`
- 忽略索引：`explain select * from tb user ignore index(idx_user_pro) where profession ='软件工程'`

### 6. 其他索引

#### （1）覆盖索引！

> 注意：覆盖索引并不是一个索引类型

覆盖索引指的是查询使用了索引，并且查询需要返回的列，在该索引中已经全部能够找到。在做查询时尽量使用覆盖索引，避免`select *`，因为很可能会出现回表查询的情况。

例如下面的两个sql语句：

- `explain select id,profession,age,status from tb user where profession="软件工程" and age=31 and status ='0';`，**这个语句由于要查询的列，都在索引中能全部找到，因此不需要回表查聚集索引，直接在二级索引中就能全部找到**。注意看后面的extra，`using where; using index`，说明需要的数据都在索引列中能找到，所以不需要回表查询数据。

![image-20250613092318580](./assets/image-20250613092318580.png)

- `explain select id,profession,age,status,name from tb user where profession="软件工程" and age=31 and status ='0';`，这个语句由于要查询的name，在二级索引中找不到，因此需要回表查询。后面的extra，`using index condition`，表示查找使用了索引，但是需要回表查询数据，性能就没有前面高。

![image-20250613092350140](./assets/image-20250613092350140.png)

#### （2）前缀索引

当字段类型为字符串(`varchar`，`text`等)、时，有时候需要索引很长的字符串，这会让索引变得很大，查询时浪费大量的磁盘I0，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率，这个索引称之为前缀索引。

- 创建语法：`create index idx_xxx_xxx on table_name(column(n));`

- 前缀长度：可以根据索引的选择性来决定，选择性是指不重复的索引值(基数)和数据表的记录总数的比值，索引选择性越高则查询效率越高。例如唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。可以用下面的sql语句来计算选择性。
  ```sql
  select count(distinct substring(email,1,5))/ count(*) from tb user;
  ```

  这里可以不断向下调整这个子字符串长度的值，例如在这里，前6个字符串和前5个字符串，选择性是一样的，那肯定要用前5个，索引越短越好。

  <img src="./assets/image-20250613095527948.png" alt="image-20250613095527948" style="zoom:67%;" />

#### （3）联合索引

单列索引：即一个索引只包含单个列；联合索引：即一个索引包含了多个列。在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引，因为联合索引很多时候可以覆盖索引，避免回表查询。

- 创建语法：`create index idx_user_phone_name on tb_user(phone, nane);`
- 索引结构：联合索引的本质，也是一个二级索引。例如上面的例子，构建出来的索引如下图所示，每个节点所存储的键值都是phone和name的组合情况，排序时先按照phone的顺序排，phone一致的情况下，按照name的顺序排。

![image-20250613100701412](./assets/image-20250613100701412.png)

### 7. 建索引原则

- 针对于数据量较大，且查询比较频繁的表建立索引。一般来说，一张表如果有百万级数据，要考虑建索引，如果只有几千条几万条，不建索引查询效率也比较高。
- 针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。
- 尽量选择区分度高的列作为索引，例如手机号、身份证号等，区分度越高，使用索引的效率越高。对于一些字段，区分度较低，建了索引效率也不高，例如性别、状态。

> 后面这两点，需要再细致了解一下

- 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。例如 `WHERE col1 = 'A' AND col2 = 'B'`这个查询，如果只有 `col1` 和 `col2` 的单列索引，数据库优化器通常只能选择其中一个它认为过滤性更好的索引（比如 `col1`）。它会先通过 `col1` 的索引找到所有 `col1='A'` 的行，然后**回表**（回到主表数据页）去逐行检查这些行是否满足 `col2='B'`。如果 `col1='A'` 的行很多，这个过程会产生大量的随机 I/O。
- 如果是字符串类型的字段，例如一篇文章的内容，字段的长度较长，可以针对于字段的特点，建立前缀索引。

## 三、SQL查询优化

### 1. explain执行计划

在select语句前加上explain即可

```sql
explain select * from user where id=1;
```

执行结果

![image-20250610221924206](./assets/image-20250610221924206.png)

- id：id值相同，从上往下执行；值不同，从大往小执行。

### 2. 主键优化

### 3. order by优化

### 4. group by优化

### 5. limit优化

### 6.  count优化

## 三、锁

## 四、日志

### 1. 慢查询日志





